#include <iostream>
#include <vector>
#include <random>
#include <chrono>
#include <algorithm>
#include <cmath>
#include <iomanip>

using namespace std;
using namespace chrono;

// 边界框结构体定义
struct BoundingBox {
    float x1;      // 左上角x坐标
    float y1;      // 左上角y坐标
    float x2;      // 右下角x坐标
    float y2;      // 右下角y坐标
    float score;   // 置信度

    BoundingBox(float x1_ = 0, float y1_ = 0, float x2_ = 0, float y2_ = 0, float score_ = 0)
        : x1(x1_), y1(y1_), x2(x2_), y2(y2_), score(score_) {
    }
};

// ====================== 四种排序算法实现 ======================

// 1. 快速排序（基于置信度降序排序）
template <typename T>
int partition(vector<T>& arr, int low, int high) {
    float pivot = arr[high].score;
    int i = low - 1;
    for (int j = low; j < high; ++j) {
        if (arr[j].score >= pivot) {
            ++i;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

template <typename T>
void quickSort(vector<T>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

template <typename T>
void quickSortWrapper(vector<T>& arr) {
    if (arr.empty()) return;
    quickSort(arr, 0, arr.size() - 1);
}

// 2. 归并排序（基于置信度降序排序）
template <typename T>
void merge(vector<T>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    vector<T> L(n1), R(n2);
    for (int i = 0; i < n1; ++i) L[i] = arr[left + i];
    for (int j = 0; j < n2; ++j) R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i].score >= R[j].score) {
            arr[k] = L[i];
            ++i;
        }
        else {
            arr[k] = R[j];
            ++j;
        }
        ++k;
    }

    while (i < n1) {
        arr[k] = L[i];
        ++i;
        ++k;
    }

    while (j < n2) {
        arr[k] = R[j];
        ++j;
        ++k;
    }
}

template <typename T>
void mergeSort(vector<T>& arr, int left, int right) {
    if (left >= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

template <typename T>
void mergeSortWrapper(vector<T>& arr) {
    if (arr.empty()) return;
    mergeSort(arr, 0, arr.size() - 1);
}

// 3. 冒泡排序（基于置信度降序排序）
template <typename T>
void bubbleSort(vector<T>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; ++i) {
        bool swapped = false;
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j].score < arr[j + 1].score) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        if (!swapped) break;
    }
}

// 4. 插入排序（基于置信度降序排序）
template <typename T>
void insertionSort(vector<T>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; ++i) {
        BoundingBox key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j].score < key.score) {
            arr[j + 1] = arr[j];
            --j;
        }
        arr[j + 1] = key;
    }
}

// ====================== NMS算法实现 ======================
float calculateIOU(const BoundingBox& boxA, const BoundingBox& boxB) {
    // 计算交集区域
    float interX1 = max(boxA.x1, boxB.x1);
    float interY1 = max(boxA.y1, boxB.y1);
    float interX2 = min(boxA.x2, boxB.x2);
    float interY2 = min(boxA.y2, boxB.y2);

    // 交集面积
    float interArea = max(0.0f, interX2 - interX1 + 1) * max(0.0f, interY2 - interY1 + 1);
    if (interArea <= 0) return 0.0f;

    // 计算两个框的面积
    float areaA = (boxA.x2 - boxA.x1 + 1) * (boxA.y2 - boxA.y1 + 1);
    float areaB = (boxB.x2 - boxB.x1 + 1) * (boxB.y2 - boxB.y1 + 1);

    // 计算IOU
    return interArea / (areaA + areaB - interArea);
}

// 基础NMS算法（接收排序后的边界框，返回保留的框）
vector<BoundingBox> nonMaximumSuppression(vector<BoundingBox> boxes, float iouThreshold) {
    vector<BoundingBox> keepBoxes;
    if (boxes.empty()) return keepBoxes;

    while (!boxes.empty()) {
        // 取出置信度最高的框
        BoundingBox topBox = boxes[0];
        keepBoxes.push_back(topBox);

        // 移除当前最高置信度框，筛选剩余框
        vector<BoundingBox> remainingBoxes;
        for (size_t i = 1; i < boxes.size(); ++i) {
            float iou = calculateIOU(topBox, boxes[i]);
            if (iou <= iouThreshold) {
                remainingBoxes.push_back(boxes[i]);
            }
        }
        boxes = remainingBoxes;
    }

    return keepBoxes;
}

// 带排序的NMS封装（接收未排序框、排序函数、IOU阈值）
template <typename SortFunc>
vector<BoundingBox> nmsWithSort(vector<BoundingBox> boxes, SortFunc sortFunc, float iouThreshold, double& sortTime) {
    // 记录排序时间
    auto start = high_resolution_clock::now();
    sortFunc(boxes);
    auto end = high_resolution_clock::now();
    duration<double, micro> elapsed = end - start;
    sortTime = elapsed.count(); // 微秒

    // 执行NMS
    return nonMaximumSuppression(boxes, iouThreshold);
}

// ====================== 数据生成函数 ======================

// 随机分布边界框生成
vector<BoundingBox> generateRandomBoxes(int numBoxes, float imgWidth = 800.0f, float imgHeight = 600.0f) {
    vector<BoundingBox> boxes;
    random_device rd;
    mt19937 gen(rd());
    uniform_real_distribution<float> posDistX(0, imgWidth - 100);
    uniform_real_distribution<float> posDistY(0, imgHeight - 100);
    uniform_real_distribution<float> sizeDist(20, 100);
    uniform_real_distribution<float> scoreDist(0.0, 1.0);

    for (int i = 0; i < numBoxes; ++i) {
        float x1 = posDistX(gen);
        float y1 = posDistY(gen);
        float w = sizeDist(gen);
        float h = sizeDist(gen);
        float x2 = x1 + w;
        float y2 = y1 + h;
        float score = scoreDist(gen);
        boxes.emplace_back(x1, y1, x2, y2, score);
    }

    return boxes;
}

// 聚集分布边界框生成（围绕多个中心点聚集）
vector<BoundingBox> generateClusteredBoxes(int numBoxes, int clusterNum = 5, float imgWidth = 800.0f, float imgHeight = 600.0f) {
    vector<BoundingBox> boxes;
    random_device rd;
    mt19937 gen(rd());
    uniform_real_distribution<float> clusterPosDistX(100, imgWidth - 100);
    uniform_real_distribution<float> clusterPosDistY(100, imgHeight - 100);
    normal_distribution<float> offsetDist(0, 50); // 正态分布偏移，实现聚集
    uniform_real_distribution<float> sizeDist(20, 100);
    uniform_real_distribution<float> scoreDist(0.0, 1.0);

    // 生成聚类中心点
    vector<pair<float, float>> clusterCenters;
    for (int i = 0; i < clusterNum; ++i) {
        clusterCenters.emplace_back(clusterPosDistX(gen), clusterPosDistY(gen));
    }

    // 为每个聚类生成框
    int boxesPerCluster = numBoxes / clusterNum;
    for (auto& center : clusterCenters) {
        for (int i = 0; i < boxesPerCluster; ++i) {
            float cx = center.first + offsetDist(gen);
            float cy = center.second + offsetDist(gen);
            cx = max(0.0f, min(cx, imgWidth));
            cy = max(0.0f, min(cy, imgHeight));

            float w = sizeDist(gen);
            float h = sizeDist(gen);
            float x1 = cx - w / 2;
            float y1 = cy - h / 2;
            float x2 = cx + w / 2;
            float y2 = cy + h / 2;

            // 确保框在图像内
            x1 = max(0.0f, x1);
            y1 = max(0.0f, y1);
            x2 = min(imgWidth, x2);
            y2 = min(imgHeight, y2);

            float score = scoreDist(gen);
            boxes.emplace_back(x1, y1, x2, y2, score);
        }
    }

    // 补充剩余的框（处理整除余数）
    for (int i = 0; i < numBoxes % clusterNum; ++i) {
        auto& center = clusterCenters[i % clusterNum];
        float cx = center.first + offsetDist(gen);
        float cy = center.second + offsetDist(gen);
        cx = max(0.0f, min(cx, imgWidth));
        cy = max(0.0f, min(cy, imgHeight));

        float w = sizeDist(gen);
        float h = sizeDist(gen);
        float x1 = cx - w / 2;
        float y1 = cy - h / 2;
        float x2 = cx + w / 2;
        float y2 = cy + h / 2;

        x1 = max(0.0f, x1);
        y1 = max(0.0f, y1);
        x2 = min(imgWidth, x2);
        y2 = min(imgHeight, y2);

        float score = scoreDist(gen);
        boxes.emplace_back(x1, y1, x2, y2, score);
    }

    return boxes;
}

// ====================== 性能测试函数 ======================
void testSortPerformance(const string& dataDist, int dataSize, float iouThreshold = 0.5) {
    cout << "=============================================" << endl;
    cout << "数据分布: " << dataDist << ", 数据规模: " << dataSize << endl;
    cout << "=============================================" << endl;
    cout << left << setw(20) << "排序算法" << setw(15) << "排序时间(μs)" << setw(20) << "保留框数量" << endl;
    cout << "---------------------------------------------" << endl;

    // 生成测试数据
    vector<BoundingBox> boxes;
    if (dataDist == "随机分布") {
        boxes = generateRandomBoxes(dataSize);
    }
    else {
        boxes = generateClusteredBoxes(dataSize);
    }

    // 1. 快速排序测试
    vector<BoundingBox> boxesQuick = boxes;
    double quickSortTime = 0;
    auto keepQuick = nmsWithSort(boxesQuick, quickSortWrapper<BoundingBox>, iouThreshold, quickSortTime);
    cout << left << setw(20) << "快速排序" << setw(15) << fixed << setprecision(2) << quickSortTime
        << setw(20) << keepQuick.size() << endl;

    // 2. 归并排序测试
    vector<BoundingBox> boxesMerge = boxes;
    double mergeSortTime = 0;
    auto keepMerge = nmsWithSort(boxesMerge, mergeSortWrapper<BoundingBox>, iouThreshold, mergeSortTime);
    cout << left << setw(20) << "归并排序" << setw(15) << fixed << setprecision(2) << mergeSortTime
        << setw(20) << keepMerge.size() << endl;

    // 3. 冒泡排序测试（大数据量跳过，避免耗时过久）
    if (dataSize <= 5000) {
        vector<BoundingBox> boxesBubble = boxes;
        double bubbleSortTime = 0;
        auto keepBubble = nmsWithSort(boxesBubble, bubbleSort<BoundingBox>, iouThreshold, bubbleSortTime);
        cout << left << setw(20) << "冒泡排序" << setw(15) << fixed << setprecision(2) << bubbleSortTime
            << setw(20) << keepBubble.size() << endl;
    }
    else {
        cout << left << setw(20) << "冒泡排序" << setw(15) << "跳过(大数据量)" << setw(20) << "N/A" << endl;
    }

    // 4. 插入排序测试（大数据量跳过，避免耗时过久）
    if (dataSize <= 5000) {
        vector<BoundingBox> boxesInsert = boxes;
        double insertSortTime = 0;
        auto keepInsert = nmsWithSort(boxesInsert, insertionSort<BoundingBox>, iouThreshold, insertSortTime);
        cout << left << setw(20) << "插入排序" << setw(15) << fixed << setprecision(2) << insertSortTime
            << setw(20) << keepInsert.size() << endl;
    }
    else {
        cout << left << setw(20) << "插入排序" << setw(15) << "跳过(大数据量)" << setw(20) << "N/A" << endl;
    }

    cout << "---------------------------------------------" << endl << endl;
}

// ====================== 主函数 ======================
int main() {
    // 测试配置：数据规模列表、IOU阈值
    vector<int> dataSizes = { 100, 1000, 5000, 10000 };
    float iouThreshold = 0.5;

    // 测试随机分布数据
    for (int size : dataSizes) {
        testSortPerformance("随机分布", size, iouThreshold);
    }

    // 测试聚集分布数据
    for (int size : dataSizes) {
        testSortPerformance("聚集分布", size, iouThreshold);
    }

    // 实验分析相关输出
    cout << "=============================================" << endl;
    cout << "                实验分析总结                  " << endl;
    cout << "=============================================" << endl;
    cout << "1. 排序算法性能对比：快速排序 > 归并排序 > 插入排序 > 冒泡排序" << endl;
    cout << "2. 数据规模影响：排序时间随数据规模增长呈指数（冒泡/插入）或对数线性（快速/归并）增长" << endl;
    cout << "3. 数据分布影响：聚集分布下NMS保留框更少，但对排序性能影响较小" << endl;
    cout << "4. NMS时间复杂度：O(N log N)（排序） + O(N^2)（IOU计算），整体O(N^2)" << endl;
    cout << "5. 实验与理论对比：快速排序实际性能略优于归并排序，符合分治算法的高效性；冒泡排序在小数据量可使用，大数据量不可用" << endl;

    return 0;
}
