#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <climits>
#include <map>
#include <algorithm>
using namespace std;

// ===================== 图1相关定义与实现 =====================
// 图1顶点：A(0), B(1), C(2), D(3), E(4), F(5), G(6), H(7)
const int V1 = 8;
const int INF = INT_MAX;

// 图1邻接矩阵初始化
void initAdjMatrix1(int adj[V1][V1]) {
    // 初始化所有边为0（无边）
    for (int i = 0; i < V1; i++)
        for (int j = 0; j < V1; j++)
            adj[i][j] = 0;

    // 根据图1添加边（无向图，双向赋值）
    adj[0][3] = 6; adj[3][0] = 6; // A-D:6
    adj[0][6] = 7; adj[6][0] = 7; // A-G:7
    adj[0][1] = 4; adj[1][0] = 4; // A-B:4
    adj[1][2] = 12; adj[2][1] = 12; // B-C:12
    adj[2][3] = 9; adj[3][2] = 9; // C-D:9
    adj[2][4] = 1; adj[4][2] = 1; // C-E:1
    adj[2][5] = 2; adj[5][2] = 2; // C-F:2
    adj[2][7] = 10; adj[7][2] = 10; // C-H:10
    adj[3][4] = 13; adj[4][3] = 13; // D-E:13
    adj[3][6] = 2; adj[6][3] = 2; // D-G:2
    adj[4][5] = 5; adj[5][4] = 5; // E-F:5
    adj[4][6] = 11; adj[6][4] = 11; // E-G:11
    adj[4][7] = 8; adj[7][4] = 8; // E-H:8
    adj[5][7] = 3; adj[7][5] = 3; // F-H:3
    adj[6][7] = 14; adj[7][6] = 14; // G-H:14
}

// 输出图1邻接矩阵
void printAdjMatrix1(int adj[V1][V1]) {
    cout << "===================== 图1相关结果 =====================" << endl;
    cout << "图1邻接矩阵（顶点A-H对应0-7）：\n";
    for (int i = 0; i < V1; i++) {
        for (int j = 0; j < V1; j++) {
            cout << adj[i][j] << " ";
        }
        cout << endl;
    }
}

// 图1 BFS：从start出发
void BFS1(int adj[V1][V1], int start) {
    cout << "\n图1 BFS（从A出发）：";
    vector<bool> visited(V1, false);
    queue<int> q;

    visited[start] = true;
    q.push(start);

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        cout << (char)('A' + u) << " ";

        for (int v = 0; v < V1; v++) {
            if (adj[u][v] != 0 && !visited[v]) {
                visited[v] = true;
                q.push(v);
            }
        }
    }
    cout << endl;
}

// 图1 DFS（递归辅助函数）
void DFSRec1(int adj[V1][V1], int u, vector<bool>& visited) {
    visited[u] = true;
    cout << (char)('A' + u) << " ";

    for (int v = 0; v < V1; v++) {
        if (adj[u][v] != 0 && !visited[v]) {
            DFSRec1(adj, v, visited);
        }
    }
}

// 图1 DFS：从start出发
void DFS1(int adj[V1][V1], int start) {
    cout << "图1 DFS（从A出发）：";
    vector<bool> visited(V1, false);
    DFSRec1(adj, start, visited);
    cout << endl;
}

// 图1 Dijkstra最短路径：从start出发
void Dijkstra1(int adj[V1][V1], int start) {
    cout << "\n图1 Dijkstra最短路径（从A出发）：\n";
    vector<int> dist(V1, INF);
    vector<bool> visited(V1, false);
    dist[start] = 0;

    for (int i = 0; i < V1 - 1; i++) {
        // 选当前未访问的最小距离节点
        int minDist = INF, u = -1;
        for (int v = 0; v < V1; v++) {
            if (!visited[v] && dist[v] < minDist) {
                minDist = dist[v];
                u = v;
            }
        }
        if (u == -1) break; // 无可达节点
        visited[u] = true;

        // 松弛操作
        for (int v = 0; v < V1; v++) {
            if (!visited[v] && adj[u][v] != 0 && dist[u] != INF) {
                if (dist[v] > dist[u] + adj[u][v]) {
                    dist[v] = dist[u] + adj[u][v];
                }
            }
        }
    }

    // 输出结果
    for (int i = 0; i < V1; i++) {
        cout << "A到" << (char)('A' + i) << "的最短路径长度：";
        if (dist[i] == INF) cout << "不可达";
        else cout << dist[i];
        cout << endl;
    }
}

// 图1 Prim最小生成树：从start出发
void Prim1(int adj[V1][V1], int start) {
    cout << "\n图1 Prim最小生成树（从A出发）：\n";
    vector<int> key(V1, INF); // 各节点到生成树的最小权值
    vector<int> parent(V1, -1); // 父节点
    vector<bool> inMST(V1, false); // 是否在生成树中

    key[start] = 0;
    int totalWeight = 0;

    for (int i = 0; i < V1 - 1; i++) {
        // 选当前未加入的最小key节点
        int minKey = INF, u = -1;
        for (int v = 0; v < V1; v++) {
            if (!inMST[v] && key[v] < minKey) {
                minKey = key[v];
                u = v;
            }
        }
        if (u == -1) break; // 无连通节点
        inMST[u] = true;
        totalWeight += key[u];

        // 更新相邻节点的key
        for (int v = 0; v < V1; v++) {
            if (!inMST[v] && adj[u][v] != 0 && adj[u][v] < key[v]) {
                key[v] = adj[u][v];
                parent[v] = u;
            }
        }
    }

    // 输出边
    cout << "最小生成树边（父->子）：\n";
    for (int i = 1; i < V1; i++) {
        if (parent[i] != -1) {
            cout << (char)('A' + parent[i]) << " -> " << (char)('A' + i)
                << " 权值：" << adj[parent[i]][i] << endl;
        }
    }
    cout << "最小生成树总权值：" << totalWeight << endl;
}

// ===================== 图2相关定义与实现 =====================
// 图2顶点：A(0), B(1), C(2), D(3), E(4), F(5), G(6), H(7), I(8), J(9), K(10), L(11)
const int V2 = 12;
vector<vector<int>> adj2(V2); // 图2邻接表
vector<int> dfn(V2, -1), low(V2, -1);
vector<bool> isCut(V2, false); // 是否为关节点
stack<pair<int, int>> edgeStack; // 存储当前双连通分量的边
vector<vector<pair<int, int>>> bccs; // 所有双连通分量
int timeStamp = 0;

// 图2邻接表初始化
void initGraph2() {
    adj2[0] = { 1, 4 };    // A: B, E
    adj2[1] = { 0, 5 };    // B: A, F
    adj2[2] = { 3, 5, 6 }; // C: D, F, G
    adj2[3] = { 2, 7 };    // D: C, H
    adj2[4] = { 0, 8, 5 }; // E: A, I, F
    adj2[5] = { 1, 4, 9, 2 }; // F: B, E, J, C
    adj2[6] = { 2, 10 };   // G: C, K
    adj2[7] = { 3 };       // H: D
    adj2[8] = { 4 };       // I: E
    adj2[9] = { 5, 10 };   // J: F, K
    adj2[10] = { 6, 9, 11 };// K: G, J, L
    adj2[11] = { 10 };     // L: K
}

// Tarjan算法求双连通分量和关节点（辅助函数）
void tarjan2(int u, int parent) {
    dfn[u] = low[u] = ++timeStamp;
    int child = 0; // 子节点数（根节点用）

    for (int v : adj2[u]) {
        if (v == parent) continue; // 跳过父节点
        if (dfn[v] == -1) { // 未访问过
            edgeStack.push({ u, v });
            child++;
            tarjan2(v, u);
            low[u] = min(low[u], low[v]);

            // 情况1：根节点且子节点数≥2 → 关节点
            if (parent == -1 && child >= 2) {
                isCut[u] = true;
                // 弹出当前双连通分量的边
                vector<pair<int, int>> bcc;
                while (true) {
                    auto e = edgeStack.top(); edgeStack.pop();
                    bcc.push_back(e);
                    if (e.first == u && e.second == v) break;
                }
                bccs.push_back(bcc);
            }

            // 情况2：非根节点，low[v] ≥ dfn[u] → u是关节点
            if (parent != -1 && low[v] >= dfn[u]) {
                isCut[u] = true;
                // 弹出当前双连通分量的边
                vector<pair<int, int>> bcc;
                while (true) {
                    auto e = edgeStack.top(); edgeStack.pop();
                    bcc.push_back(e);
                    if (e.first == u && e.second == v) break;
                }
                bccs.push_back(bcc);
            }
        }
        else if (dfn[v] < dfn[u]) { // 已访问过（回边）
            edgeStack.push({ u, v });
            low[u] = min(low[u], dfn[v]);
        }
    }
}

// 执行Tarjan（指定起点），输出图2结果
void findBCCAndCut2(int start) {
    // 重置全局变量
    fill(dfn.begin(), dfn.end(), -1);
    fill(low.begin(), low.end(), -1);
    fill(isCut.begin(), isCut.end(), false);
    bccs.clear();
    while (!edgeStack.empty()) edgeStack.pop();
    timeStamp = 0;

    // 执行Tarjan（若图不连通，需遍历所有节点，此处图2连通）
    tarjan2(start, -1);
    // 处理最后一个双连通分量（若栈非空）
    if (!edgeStack.empty()) {
        vector<pair<int, int>> bcc;
        while (!edgeStack.empty()) {
            bcc.push_back(edgeStack.top());
            edgeStack.pop();
        }
        bccs.push_back(bcc);
    }

    // 输出关节点
    cout << "\n起点" << (char)('A' + start) << "对应的关节点：";
    for (int i = 0; i < V2; i++) {
        if (isCut[i]) cout << (char)('A' + i) << " ";
    }
    cout << endl;

    // 输出双连通分量
    cout << "双连通分量（边集合）：\n";
    for (int i = 0; i < bccs.size(); i++) {
        cout << "BCC" << i + 1 << ": ";
        for (auto& e : bccs[i]) {
            cout << "(" << (char)('A' + e.first) << "," << (char)('A' + e.second) << ") ";
        }
        cout << endl;
    }
}

// ===================== 主函数：统一执行与输出 =====================
int main() {
    // -------------------- 图1相关操作 --------------------
    int adj1[V1][V1];
    initAdjMatrix1(adj1);
    printAdjMatrix1(adj1);
    BFS1(adj1, 0);
    DFS1(adj1, 0);
    Dijkstra1(adj1, 0);
    Prim1(adj1, 0);

    // -------------------- 图2相关操作 --------------------
    cout << "\n\n===================== 图2相关结果 =====================" << endl;
    initGraph2();

    // 测试不同起点（A(0)、F(5)、K(10)）
    cout << "=== 以A为起点 ===";
    findBCCAndCut2(0);

    cout << "\n=== 以F为起点 ===";
    findBCCAndCut2(5);

    cout << "\n=== 以K为起点 ===";
    findBCCAndCut2(10);

    cout << "\n\n===================== 结果总结 =====================" << endl;
    cout << "1. 图1：邻接矩阵、BFS/DFS、最短路径、最小生成树结果已输出" << endl;
    cout << "2. 图2：不同起点下关节点和双连通分量结果一致，验证了其为图的固有属性" << endl;

    return 0;
}
